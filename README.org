
#+TITLE: Zoom Native Recorder (Windows)

Zoom has many different client SDKs, among all available one, the only thing
that we could possibly use on a cloud setup is the Windows SDK. This project is
a modified version of the original SDK under demo/sdk_demo, and renamed as
/recorder/.

* What Does It Do?
This is a windows application which does the following:
- join a conference with a given ID
- start to tap into audio and video streams once the meeting starts
- TODO: open a Win32 pipes (shared memory) to communicate with recording process
  which does the video composition as well as H264 encoding.
- once meeting ends, the process should just die

* How To Run This?
This is built with Visual Studio 2019. Please note that only *Release* version
built. (Same as the original demo/sdk__demo). To run this, just open
zoom-recorder.sln and run from there. Once successfully built, a binary will be
dropped to bin/ folder.

** Recording
The recording capability is done with a unpublished RAW data access API that we
got from Zoom development team. Currently, it's not possible to run this with a
corp account (That's a bug that they are trying to address). So for now, please
use the credential specified in the sln file.

** Dependency
- This depends on files under bin/. Please note that you can't run both
  recorder/ and demo/sdk__demo at the same time, as they both will try to modify
  files under bin/ and causes random crashes.
- There is no requirement of having a mic or camera at all.

** Hack
In the original SDK, there is a limitation that a single machine can only run
one instance of SDK. What they did was to create a global named event and
detected if it exists already. Based on my understanding, container has no its
own kernel object namespace (I could be wrong on this one). So the only way for
us to run this is to have a single VM to run one SDK. VM preparation is usually
on demand, but can take couple minutes based on my experience with azure. So I
implemented a hack which is to kill this Event handle during the process
initialization phase. This so far works well and allows us to run multiple SDK
instances on a given machine. (Although we do have to wait one instance
finishing initialization before we start another one)

** Command Line Parameters
This tool supports a rich set of command line options. Many of them are added
during the phase when I don't fully understand zoom's authentication model. I
believe at the time when we need to go production, we will have to use
username/password of a given user which has the special RAW api privilege turned on.

* Status of This App
- Currently, this will write file to c:\temp\audio.bin, video.bin, and
  video.meta. (Please pre-create this folder)
- The code quality is for prototyping. So there are still a bit work to be done
  to make it production quality. However, since this is NOT a long running

* Code Structure
- Main.cpp has a window message loop which is required as the underneath Zoom
  SDK is a UX app. Most of our code changes happen in /MeetingServiceMgr.cpp/
- I suggest to follow the [[https://clang.llvm.org/docs/ClangFormat.html][ClangFormat]] for code under this project

* Data Flow

#+BEGIN_SRC dot :file flow2.png  :exports results
  digraph G {
    rankdir=LR;
    subgraph cluster_machine {
      label="Windows Machine"
      subgraph cluster_c0 {
        label="Recorder Process (c++)"
        MWMO [label="MsgWaitForMultipleObjects"]
        PMSG [label="Peek/Dispatch Message"]
        PCF [label="PipeClient::InsertData"]
        PCP [label="PipeClient::ProcessQueue"]
        PCS [label="PipeClient::Send"]

        MWMO->PMSG->MWMO;
        PMSG->PCF->PMSG;
        MWMO->PCP->MWMO;

        PCP->PCS;
        PCF->PCS;
      }
      subgraph cluster_c1 {
        label="MeetingProcessor (go)"
        PS [label="PipeServer"]
      }
    }

    subgraph cluster_c2 {
      label="MediaFrontDoor"
      GS [label="gRPC server"]
    }

    PCS->PS [label="serialized protobuf\nover pipe"]
    PS->GS [label="gRPC"]
  }

#+END_SRC

Since the whole Zoom native app runs on the single thread, we'll have to use
that thread to handle both windows message as well as the IO. The flow will be

- When the zoom recorder starts, it'll CreateFile on an existing named pipe
- The main thread will wait through MsgWaitForMultipleObject(MWMO) to be able to
  process windows message as well as the Overlapped IO event. Note that MWMO can
  only handle up to 64 handles
- when a audio/video frame is given, if previous IO has been done, it'll do
  overlapped WriteFile() on that named pipe with an event. Otherwise, it'll be
  queued.
- MWMO will be waked up when the IO is done, if there is queued data, it'll
  start to process the queue.

For future compatibility, we'll use a protobuf definition to define the data
exchange between the Zoom native recorder and the meeting processor. The
protobuf will be serialized and deserialized by these 2 processes.

* How To View Recordings
- For audio, it's recorded as 32k, single channel, PCM data. I have used
  Audacity to listen to the file
- For video, I use [[http://dsplab.diei.unipg.it/software/pyuv_raw_video_sequence_player][PYUV]] to view the recording. The format is YUV, 420, 640X480
I have verified both work.

* Extra Info
- Please see [[https://github.com/zoom/zoom-sdk-windows/blob/master/README.md][ZOOM original README]]
- We'll use jira to track any work items, there are still many. Will update the
  README once set up.
